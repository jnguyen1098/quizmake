::Q1::[html]Why does this program compile with warning(s)?<br><br>\#include &lt;stdlib.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;double foo \= \{CUSTOM.random_digit\}.\{CUSTOM.random_digit\}\{CUSTOM.random_digit\};<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("Hello world!\\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =The programmer didn't \#include &lt;stdio.h&gt; # Yup, you need this to call printf() ~The programmer should have used puts() instead # Nope, puts() and printf() accomplish nearly the same thing in this context ~There is nothing wrong with the program # There certainly is something wrong with this program. Compile if you give up! ~&lt;stdlib.h&gt; is deprecated (obsolete) #  &lt;stdlib.h&gt; is one of the most important libraries!}

::Q2::[html]Trace this code and find the output.<br><br>\#include &lt;stdio.h&gt;<br>\#include &lt;stdlib.h&gt;<br>\#include &lt;string.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;char *fred \= malloc(sizeof(char) * 512);<br>&nbsp;&nbsp;&nbsp;&nbsp;int quux \= 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;double baz \= 37.2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if ((int)baz &gt; quux) \{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(fred, "My father's a character.");<br>&nbsp;&nbsp;&nbsp;&nbsp;\} else \{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(fred, "You got to get it while you can.");<br>&nbsp;&nbsp;&nbsp;&nbsp;\}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\\n", fred);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =My father's a character. # Yes. baz is bigger than quux so "My father's a character." is copied over. ~You got to get it while you can. # No. Trace again. ~Opposition is true friendship. # Not even close. ~My forte is awkwardness. #  Not even close.}

::Q3::[html]True or False\:<br><br>C uses dynamic type-checking (i.e. types are checked when you run the program, as opposed to when you compile it)
{ =False # C actually uses static type-checking ~True #  Think again.}

::Q4::[html]Why won't this code compile?<br><br>\#include &lt;stdlib.h&gt;<br>\#include &lt;string.h&gt;<br>\#include &lt;signal.h&gt;<br>\#include &lt;stdbool.h&gt;<br>\#include &lt;stdio.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;char fred[] \= "Van Halen is a work in progress.";<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\\n", fred);<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0<br>\}
{ =The programmer forgot to put a semicolon on the return # Correct. ~fred is incorrectly initialized # fred is correctly initialized as a string ~\#include &lt;signal.h&gt; is breaking gcc # The signal.h standard library won't break anything even if not used ~\#include &lt;stdbool.h&gt; is breaking gcc #  The stdbool.h standard library won't break anything even if not used}

::Q5::[html]Say you want to dynamically allocate a 2D array of unsigned short int. Which would be the correct way to declare it?
{ =unsigned short int **fred; # Correct; you would need a pointer to a unsigned short int pointer. ~unsigned short int fred; # Incorrect. This only declares a single unsigned short int. ~unsigned short int *fred; # Incorrect. This only creates a 1D array of unsigned short int. ~unsigned short int ***fred; #  Incorrect. This creates a whopping 3D array of unsigned short int.}

::Q6::[html]What will this program output?<br><br>\#include &lt;stdio.h&gt;<br>\#include &lt;signal.h&gt;<br>\#include &lt;stdio.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;float fred \= 1.53;<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("%f\\n", fred);<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =1.530000 # By default, the %f print specifier displays 6 significant digits ~This program doesn't compile. # Yes it does! It doesn't even carry any warnings ~1.53 # Not entirely. Almost there. ~1 #  Nope; this is a float}

::Q7::[html]Given the following makefile, how would you remove all compiled (not source) files?<br><br>CC \= gcc<br>CFLAGS \= -Wall -std\=c99<br><br>run\:<br>&nbsp;&nbsp;&nbsp;&nbsp;./a.out<br><br>clean\:<br>&nbsp;&nbsp;&nbsp;&nbsp;rm -rf *.o
{ =make clean # Yes, 'clean' is customarily the name most people use for cleaning up ~make run # No, this is for running the program ~make all # No, this recipe doesn't even exist in the makefile. It would usually be used to make all of the program's object files and libraries though ~make #  No, this defaults to the first recipe, which is 'run'}

::Q8::[html]This program has a big flaw in it. Would this flaw be discovered at compile-time or run-time?<br><br>\#include &lt;stdio.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;char fred[] \= "My father's a character.";<br>&nbsp;&nbsp;&nbsp;&nbsp;fred[372] \= '4';<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\\n", fred);<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =Because it is undefined behaviour, we don't actually know # Trick question, sorry. It depends on a few factors. The program may crash on startup, or the compiler might warn you. That's the thing about undefined behaviour\: it's unpredictable. ~Run-time # Not always. ~Compile-time #  Not always.}

::Q9::[html]Find the error in the code.<br><br>\#include &lt;stdio.h&gt;<br>\#include &lt;stdlib.h&gt;<br>\#include &lt;string.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;double fred[] \= "I am a serious guy.";<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\\n", fred);<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =double fred[] should be declared as char fred[] instead # Yes, because we are initializing a string, we need a char array ~There is nothing wrong with the code # There totally is something wrong with this code ~You don't need to \#include &lt;stdio.h&gt; # You do. You need it to call print() ~This program should return something other than 0 #  0 is actually used to successful termination, so it's fine}

::Q10::[html]True or False?<br><br>A binary tree always has three leaf nodes, hence the name "binary tree".
{ =False # Binary actually means "two", so three is indeed incorrect. ~True #  Sorry but no.}

::Q11::[html]How many times will "My father's a character." print?<br><br>\#include &lt;stdio.h&gt;<br>\#include &lt;sys/types.h&gt;<br>\#include &lt;unistd.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;fork();<br>&nbsp;&nbsp;&nbsp;&nbsp;fork();<br>&nbsp;&nbsp;&nbsp;&nbsp;fork();<br>&nbsp;&nbsp;&nbsp;&nbsp;puts("My father's a character.");<br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =8 times # Correct; every instance of fork() will cause the next calls to occur twice, and the next ones to occur four times, etc; it's 2^(number of fork() calls) ~3 times # How many processes are there every time fork() is called? ~0 times # puts() is just as capable of printing "My father's a character." as printf() is, so try again ~1 time #  Try again.}

::Q12::[html]Which of the following declarations refers to a pointer to a function that takes in a(n) unsigned short int, a(n) signed long long int and returns a(n) unsigned?
{ =unsigned (*fred)(signed long long int, unsigned short int); # Correct. Because of the asterisk's (*) low precedence, it is important to use parentheses to ensure correct operator precedence for fred. ~unsigned quux(unsigned short int, signed long long int); # Incorrect. quux is just a function, not a function pointer. ~short int baz(unsigned short int, signed long long int); # Incorrect. baz shouldn't return short int. ~short int (*foo)(signed long long int, unsigned short int); #  Incorrect. Even though it *IS* a function pointer, it shouldn't return short int.}

::Q13::[html]This program was supposed to sum up all the numbers in the array, but the programmer made a huge mistake. Correct the flawed line if possible.<br><br>\#include &lt;stdio.h&gt;<br><br>int main(void)<br>\{<br>&nbsp;&nbsp;&nbsp;&nbsp;int fred[5] \= \{58, 44, 41, 54, 98\};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;int baz \= 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for (int quux \= 0; quux &lt;\= sizeof(fred); quux++) \{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baz \= baz + fred[quux];<br>&nbsp;&nbsp;&nbsp;&nbsp;\}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>\}
{ =for (int quux \= 0; quux &lt; sizeof(fred)/sizeof(fred[0]); quux++) # Correct. sizeof(fred) merely finds the total memory usage of the array, not the number of elements. By dividing it by the size of a single element, only then can we find the array's length. ~for (int quux \= 0; quux &lt; sizeof(fred); quux++) # Incorrect. sizeof(fred) on its own will only give you the array's size as a whole, not the number of elements. ~This code runs fine. # Clearly it doesn't. ~for (int quux \= 0; quux &lt; sizeof(fred); quux--) #  No, we start at index 0. If we go backwards, it's undefined behaviour.}

